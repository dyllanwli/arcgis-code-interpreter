# arcgis-code-interpreter
backend

# Usage 
1. add .env 
e.g. 
```
REDIS_URL=redis://
OPENAI_API_KEY=sk-
```
2. install and run ingest
```
pip install -r requirements.txt

cd ingest
python ingest.py

```

3. host the server

```

bash run.sh
# or
uvicorn api.app:app --host 0.0.0.0 --port 3000
```

# Documentation from DevPost (ArcGIS Buddy)

## Inspiration
At ESRI, our primary mission has always centered on education, followed by offering our exceptional software solutions. In line with this ethos, our inspiration for ArcGIS Buddy stemmed from the desire to create a user-friendly documentation aid for ArcGIS. Our goal is to empower users to effortlessly interact with our app and receive immediate answers to their questions, making ArcGIS accessible to anyone, regardless of their background or expertise. ArcGIS Buddy's primary objective is to educate people worldwide about GIS, enabling them to effectively address real-world challenges and find innovative solutions to pressing issues.

## What does it do?
ArcGIS Buddy revolutionizes the learning process for ArcGIS by providing an intuitive and interactive platform. Users can seamlessly engage in conversations with our app, enhancing the learning experience and making it more enjoyable.

# How did we build it?

![ArcGIS Buddy](https://i.ibb.co/tJvQLGh/Screenshot-2023-07-23-at-09-36-12.png)

## Front-end
To ensure a smooth and customizable interface, we utilized Next.js, TypeScript to create reusable components. This approach allowed us to design an interface that caters to users of all skill levels, fostering a welcoming environment for learning ArcGIS. We incorporated ESRI's Calcite Design System in our front-end design. 

## Back-end 
For the core of our application, we leveraged cutting-edge machine learning and deep learning techniques. We combined the state-of-the-art Large Language Model (LLM), tailored specifically for extensive **_ArcGIS Documentation_**, to comprehend and respond to user queries accurately. We integrated the ArcGIS Python API for shapefile analysis and spatial analysis to provide more contextually accurate solutions. 

+ **Data Collection:**
We collected a vast corpus of ArcGIS documentation to train our LLM model. This collection included ESRI's official documentation, developer resources, and user guides, which together served as a comprehensive knowledge base for our system.

+ **Data Persistence:**
We used Faiss (Johnson et al. 2019) to store the data in a vectorized format. This method allows us to retrieve the data quickly and provide the user with the most relevant information.

+ **Data Retrieval:**
We integrated Map Reduce to retrieve the data from the Faiss database. The Map Reduce chain applies an LLM model to each document individually (the Map step), treating the chain output as a new document. It then passes all the new documents to a separate combined documents chain to get a single output (the Reduce step). If necessary, it can optionally first compress or collapse the mapped documents to ensure they fit in the combined documents chain (which will often pass them to an LLM). This compression step is performed recursively if required.

![Map Reduce](https://python.langchain.com/assets/images/map_reduce-c65525a871b62f5cacef431625c4d133.jpg)

+ **Plan and Execute:**
The core of our application assigns and conducts different tasks. We use a Chain-of-Thought (Jason et al. 2022) design to plan and execute the user's intent. A GPT-4 agent serves as a planner, leading all tasks in the application. The planner checks the result generated by the executor asynchronously using the following format until the final answer is generated:

```
Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [Search]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question
```

+ **ArcGIS Spatial Analysis Integration:**
We incorporated the ArcGIS Python API to conduct spatial analysis on the shapefile. After the user uploads the shapefile, the ArcGIS Python API retrieves attributes from the shapefile, divides the problem, and conducts spatial analysis. The API then returns the results to the user.

## Challenges we faced
One of the primary challenges we encountered was scraping the vast ArcGIS documentation. This task required substantial effort and time to ensure accuracy and completeness. Additionally, optimizing our model's runtime speed proved to be a significant hurdle to the overall user experience.

## Accomplishments we are proud of
We are proud to have developed a web app that aids in the understanding and application of ArcGIS. We were really proud when we were able to create a feature that enables the uploading and analysis of shapefiles.

## What's next for ArcGIS Buddy?
This application can be further trained to educate users on any ESRI software. ArcGIS Buddy represents our commitment to providing accessible and interactive learning resources for ArcGIS. With this app, we strive to empower users worldwide to use their own data to do their analysis.

## References:
+ [FAISS by Facebook Research](https://github.com/facebookresearch/faiss)
+ [Chain-of-Thought: Towards Conversational Agents that Can Plan and Reason](https://arxiv.org/abs/2201.11903)
